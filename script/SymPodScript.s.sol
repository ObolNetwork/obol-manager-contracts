// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "forge-std/Script.sol";
import {SymPodProofParser} from "src/test/libraries/SymPodProofParser.sol";
import {BeaconChainProofs} from "src/libraries/BeaconChainProof.sol";
import {SymPod} from "src/symbiotic/SymPod.sol";


// Calls the verify validators balance checkpoint on the SymPod
// We pass in the proof file generated by the proof generator repo
contract SymPodVerifyBalanceCPScript is Script {
  SymPodProofParser proofParser;
  BeaconChainProofs.BalanceRegistryProof balanceContainerProof;
  BeaconChainProofs.BalancesMultiProof validatorBalancesProof;

  constructor() {
    proofParser = new SymPodProofParser();
  }

  function setUp(address symPodAddress, string memory proofPath) public {
    uint256 privKey = vm.envUint("PRIVATE_KEY");

    // parse the proof path
    proofParser.setJSONPath(proofPath);

    balanceContainerProof = BeaconChainProofs.BalanceRegistryProof({
      balanceListRoot: proofParser.getBalanceListRoot(),
      proof: proofParser.getBalanceListRootProofAgainstBlockRoot()
    });

    bytes32[] memory validatorPubKeyHashes = proofParser.getValidatorPubKeyHashes();
    validatorBalancesProof = BeaconChainProofs.BalancesMultiProof({
      proof: proofParser.getValidatorBalancesAgainstBalanceRootMultiProof(),
      validatorPubKeyHashes: validatorPubKeyHashes,
      validatorBalanceRoots: proofParser.getValidatorBalancesRoot()
    });

    vm.startBroadcast(privKey);
    SymPod(payable(symPodAddress)).verifyBalanceCheckpointProofs(balanceContainerProof, validatorBalancesProof);
    vm.stopBroadcast();
  }
}


// Calls the verify validators withdrawal credential on the SymPod
// We pass in the proof file generated by the proof generator repo
contract SymPodVerifyValidatorWCScript is Script {
  SymPodProofParser proofParser;
  BeaconChainProofs.ValidatorRegistryProof validatorRegistryProof;
  BeaconChainProofs.ValidatorsMultiProof validatorProof;

  constructor() {
    proofParser = new SymPodProofParser();
  }

  function setUp(uint64 timestamp, address symPodAddress, string memory proofPath) public {
    uint256 privKey = vm.envUint("PRIVATE_KEY");

    // parse the proof path
    proofParser.setJSONPath(proofPath);

    validatorRegistryProof = BeaconChainProofs.ValidatorRegistryProof({
      validatorListRoot: proofParser.getValidatorListRoot(),
      proof: proofParser.getValidatorListRootProofAgainstBlockRoot()
    });

    uint40[] memory validatorIndices = proofParser.getValidatorIndices();

    validatorProof = BeaconChainProofs.ValidatorsMultiProof({
      validatorFields: proofParser.getValidatorFields(validatorIndices.length),
      proof: proofParser.getValidatorFieldsAgainstValidatorListMultiProof(),
      validatorIndices: validatorIndices
    });

    vm.startBroadcast(privKey);
    SymPod(payable(symPodAddress)).verifyValidatorWithdrawalCredentials(
      timestamp, validatorRegistryProof, validatorProof
    );
    vm.stopBroadcast();
  }
}

contract SymPodVerifyExpiredBalanceScript is Script {
  SymPodProofParser proofParser;
  BeaconChainProofs.ValidatorRegistryProof validatorRegistryProof;
  BeaconChainProofs.ValidatorProof validatorProof;

  constructor() {
    proofParser = new SymPodProofParser();
  }

  function setUp(uint64 timestamp, address symPodAddress, string memory proofPath) public {
    uint256 privKey = vm.envUint("PRIVATE_KEY");

    // parse the proof fil
    proofParser.setJSONPath(proofPath);

    validatorRegistryProof = BeaconChainProofs.ValidatorRegistryProof({
      validatorListRoot: proofParser.getValidatorListRoot(),
      proof: proofParser.getValidatorListRootProofAgainstBlockRoot()
    });

    uint40 validatorIndex = uint40(proofParser.getValidatorIndex());
    validatorProof = BeaconChainProofs.ValidatorProof({
      validatorFields: proofParser.getSingleValidatorFields(),
      proof: abi.encodePacked(proofParser.getValidatorFieldsProof()),
      validatorIndex: validatorIndex
    });

    vm.startBroadcast(privKey);
    SymPod(payable(symPodAddress)).verifyExpiredBalance(timestamp, validatorRegistryProof, validatorProof);
    vm.stopBroadcast();
  }
}

contract SymPodVerifyExceedBalanceDeltaScript is Script {
  SymPodProofParser proofParser;
  BeaconChainProofs.BalanceRegistryProof balanceRegistryProof;
  BeaconChainProofs.BalanceProof balanceProof;

  constructor() {
    proofParser = new SymPodProofParser();
  }

  function setUp(uint64 timestamp, address symPodAddress, string memory proofPath) public {
    uint256 privKey = vm.envUint("PRIVATE_KEY");

    // parse the proof fil
    proofParser.setJSONPath(proofPath);

    balanceRegistryProof = BeaconChainProofs.BalanceRegistryProof({
      balanceListRoot: proofParser.getBalanceListRoot(),
      proof: proofParser.getBalanceListRootProofAgainstBlockRoot()
    });

    balanceProof = BeaconChainProofs.BalanceProof({
      proof: proofParser.getValidatorBalanceproof(),
      validatorPubKeyHash: proofParser.getValidatorPubKeyHash(),
      validatorBalanceRoot: proofParser.getValidatorBalanceRoot()
    });

    vm.startBroadcast(privKey);
    SymPod(payable(symPodAddress)).verifyExceedBalanceDelta(timestamp, balanceRegistryProof, balanceProof);
    vm.stopBroadcast();
  }
}
